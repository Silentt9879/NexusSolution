{"version":3,"file":"static/js/485.bbbd57d7.chunk.js","mappings":"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","sources":["../node_modules/@portabletext/toolkit/src/asserters.ts","../node_modules/@portabletext/toolkit/src/sortMarksByOccurences.ts","../node_modules/@portabletext/toolkit/src/nestLists.ts","../node_modules/@portabletext/toolkit/src/spanToPlainText.ts","../node_modules/@portabletext/toolkit/src/types.ts","../node_modules/@portabletext/react/src/components/marks.tsx","../node_modules/@portabletext/react/src/warnings.ts","../node_modules/@portabletext/react/src/components/unknown.tsx","../node_modules/@portabletext/react/src/components/defaults.tsx","../node_modules/@portabletext/react/src/components/list.tsx","../node_modules/@portabletext/react/src/components/merge.ts","../node_modules/@portabletext/react/src/react-portable-text.tsx","../node_modules/@portabletext/toolkit/src/buildMarksTree.ts","pages/SinglePostPage.js","client.js"],"sourcesContent":["import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\n\nimport type {ToolkitNestedPortableTextSpan, ToolkitPortableTextList, ToolkitTextNode} from './types'\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text span.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text span, otherwise false\n */\nexport function isPortableTextSpan(\n  node: ArbitraryTypedObject | PortableTextSpan,\n): node is PortableTextSpan {\n  return (\n    node._type === 'span' &&\n    'text' in node &&\n    typeof node.text === 'string' &&\n    (typeof node.marks === 'undefined' ||\n      (Array.isArray(node.marks) && node.marks.every((mark) => typeof mark === 'string')))\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text block.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text block, otherwise false\n */\nexport function isPortableTextBlock(\n  node: PortableTextBlock | TypedObject,\n): node is PortableTextBlock {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type === 'string' &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== '@' &&\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!('markDefs' in node) ||\n      !node.markDefs ||\n      (Array.isArray(node.markDefs) &&\n        // Every mark definition needs to have an `_key` to be mappable in child spans\n        node.markDefs.every((def) => typeof def._key === 'string'))) &&\n    // `children` is required and needs to be an array\n    'children' in node &&\n    Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child === 'object' && '_type' in child)\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted portable list item block.\n *\n * @param block - Block to check\n * @returns True if valid Portable Text list item block, otherwise false\n */\nexport function isPortableTextListItemBlock(\n  block: PortableTextBlock | TypedObject,\n): block is PortableTextListItemBlock {\n  return (\n    isPortableTextBlock(block) &&\n    'listItem' in block &&\n    typeof block.listItem === 'string' &&\n    (typeof block.level === 'undefined' || typeof block.level === 'number')\n  )\n}\n\n/**\n * Loose check to determine if block is a toolkit list node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param block - Block to check\n * @returns True if toolkit list, otherwise false\n */\nexport function isPortableTextToolkitList(\n  block: TypedObject | ToolkitPortableTextList,\n): block is ToolkitPortableTextList {\n  return block._type === '@list'\n}\n\n/**\n * Loose check to determine if span is a toolkit span node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param span - Span to check\n * @returns True if toolkit span, otherwise false\n */\nexport function isPortableTextToolkitSpan(\n  span: TypedObject | ToolkitNestedPortableTextSpan,\n): span is ToolkitNestedPortableTextSpan {\n  return span._type === '@span'\n}\n\n/**\n * Loose check to determine if node is a toolkit text node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param node - Node to check\n * @returns True if toolkit text node, otherwise false\n */\nexport function isPortableTextToolkitTextNode(\n  node: TypedObject | ToolkitTextNode,\n): node is ToolkitTextNode {\n  return node._type === '@text'\n}\n","import type {PortableTextSpan, TypedObject} from '@portabletext/types'\n\nimport {isPortableTextSpan} from './asserters'\n\nconst knownDecorators = ['strong', 'em', 'code', 'underline', 'strike-through']\n\n/**\n * Figures out the optimal order of marks, in order to minimize the amount of\n * nesting/repeated elements in environments such as HTML. For instance, a naive\n * implementation might render something like:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded text</strong>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a> and some bolded text\n * </strong>\n * ```\n *\n * This is particularly necessary for cases like links, where you don't want multiple\n * individual links for different segments of the link text, even if parts of it are\n * bolded/italicized.\n *\n * This function is meant to be used like: `block.children.map(sortMarksByOccurences)`,\n * and is used internally in {@link buildMarksTree | `buildMarksTree()`}.\n *\n * The marks are sorted in the following order:\n *\n *  1. Marks that are shared amongst the most adjacent siblings\n *  2. Non-default marks (links, custom metadata)\n *  3. Decorators (bold, emphasis, code etc), in a predefined, preferred order\n *\n * @param span - The current span to sort\n * @param index - The index of the current span within the block\n * @param blockChildren - All children of the block being sorted\n * @returns Array of decorators and annotations, sorted by \"most adjacent siblings\"\n */\nexport function sortMarksByOccurences(\n  span: PortableTextSpan | TypedObject,\n  index: number,\n  blockChildren: (PortableTextSpan | TypedObject)[],\n): string[] {\n  if (!isPortableTextSpan(span) || !span.marks) {\n    return []\n  }\n\n  if (!span.marks.length) {\n    return []\n  }\n\n  // Slicing because we'll be sorting with `sort()`, which mutates\n  const marks = span.marks.slice()\n  const occurences: Record<string, number> = {}\n  marks.forEach((mark) => {\n    occurences[mark] = 1\n\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex]\n\n      if (\n        sibling &&\n        isPortableTextSpan(sibling) &&\n        Array.isArray(sibling.marks) &&\n        sibling.marks.indexOf(mark) !== -1\n      ) {\n        occurences[mark]++\n      } else {\n        break\n      }\n    }\n  })\n\n  return marks.sort((markA, markB) => sortMarks(occurences, markA, markB))\n}\n\nfunction sortMarks<U extends string, T extends Record<U, number>>(\n  occurences: T,\n  markA: U,\n  markB: U,\n): number {\n  const aOccurences = occurences[markA]\n  const bOccurences = occurences[markB]\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences\n  }\n\n  const aKnownPos = knownDecorators.indexOf(markA)\n  const bKnownPos = knownDecorators.indexOf(markB)\n\n  // Sort known decorators last\n  if (aKnownPos !== bKnownPos) {\n    return aKnownPos - bKnownPos\n  }\n\n  // Sort other marks simply by key\n  return markA.localeCompare(markB)\n}\n","import type {PortableTextBlock, PortableTextListItemBlock, TypedObject} from '@portabletext/types'\n\nimport {\n  isPortableTextListItemBlock,\n  isPortableTextSpan,\n  isPortableTextToolkitList,\n} from './asserters'\nimport type {\n  ToolkitListNestMode,\n  ToolkitPortableTextDirectList,\n  ToolkitPortableTextHtmlList,\n  ToolkitPortableTextList,\n  ToolkitPortableTextListItem,\n} from './types'\n\nexport type ToolkitNestListsOutputNode<T> =\n  | T\n  | ToolkitPortableTextHtmlList\n  | ToolkitPortableTextDirectList\n\n/**\n * Takes an array of blocks and returns an array of nodes optimized for rendering in HTML-like\n * environment, where lists are nested inside of eachother instead of appearing \"flat\" as in\n * native Portable Text data structures.\n *\n * Note that the list node is not a native Portable Text node type, and thus is represented\n * using the {@link ToolkitPortableTextList | `@list`} type name (`{_type: '@list'}`).\n *\n * The nesting can be configured in two modes:\n *\n * - `direct`: deeper list nodes will appear as a direct child of the parent list\n * - `html`, deeper list nodes will appear as a child of the last _list item_ in the parent list\n *\n * When using `direct`, all list nodes will be of type {@link ToolkitPortableTextDirectList},\n * while with `html` they will be of type {@link ToolkitPortableTextHtmlList}\n *\n * These modes are available as {@link LIST_NEST_MODE_HTML} and {@link LIST_NEST_MODE_DIRECT}.\n *\n * @param blocks - Array of Portable Text blocks and other arbitrary types\n * @param mode - Mode to use for nesting, `direct` or `html`\n * @returns Array of potentially nested nodes optimized for rendering\n */\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct',\n): (T | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'html',\n): (T | ToolkitPortableTextHtmlList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct' | 'html',\n): (T | ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: ToolkitListNestMode,\n): ToolkitNestListsOutputNode<T>[] {\n  const tree: ToolkitNestListsOutputNode<T>[] = []\n  let currentList: ToolkitPortableTextList | undefined\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i]\n    if (!block) {\n      continue\n    }\n\n    if (!isPortableTextListItemBlock(block)) {\n      tree.push(block)\n      currentList = undefined\n      continue\n    }\n\n    // Start of a new list?\n    if (!currentList) {\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // New list item within same list?\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block)\n      continue\n    }\n\n    // Different list props, are we going deeper?\n    if ((block.level || 1) > currentList.level) {\n      const newList = listFromBlock(block, i, mode)\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items.\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // we actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n\n        // Clone the last child while adding our new list as the last child of it\n        const lastListItem = currentList.children[\n          currentList.children.length - 1\n        ] as ToolkitPortableTextListItem\n\n        const newLastChild: ToolkitPortableTextListItem = {\n          ...lastListItem,\n          children: [...lastListItem.children, newList],\n        }\n\n        // Swap the last child\n        currentList.children[currentList.children.length - 1] = newLastChild\n      } else {\n        ;(currentList as ToolkitPortableTextDirectList).children.push(\n          newList as ToolkitPortableTextDirectList,\n        )\n      }\n\n      // Set the newly created, deeper list as the current\n      currentList = newList\n      continue\n    }\n\n    // Different list props, are we going back up the tree?\n    if ((block.level || 1) < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, block)\n      if (match) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      }\n\n      // Similar parent can't be found, assume new list\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // Different list props, different list style?\n    if (block.listItem !== currentList.listItem) {\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, {level: block.level || 1})\n      if (match && match.listItem === block.listItem) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      } else {\n        currentList = listFromBlock(block, i, mode)\n        tree.push(currentList)\n        continue\n      }\n    }\n\n    // oxlint-disable-next-line no-console\n    console.warn('Unknown state encountered for block', block)\n    tree.push(block)\n  }\n\n  return tree\n}\n\nfunction blockMatchesList(block: PortableTextBlock, list: ToolkitPortableTextList) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem\n}\n\nfunction listFromBlock(\n  block: PortableTextListItemBlock,\n  index: number,\n  mode: ToolkitListNestMode,\n): ToolkitPortableTextList {\n  return {\n    _type: '@list',\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block],\n  }\n}\n\nfunction findListMatching<T extends TypedObject | PortableTextBlock>(\n  rootNode: T,\n  matching: Partial<PortableTextListItemBlock>,\n): ToolkitPortableTextList | undefined {\n  const level = matching.level || 1\n  const style = matching.listItem || 'normal'\n  const filterOnType = typeof matching.listItem === 'string'\n  if (\n    isPortableTextToolkitList(rootNode) &&\n    (rootNode.level || 1) === level &&\n    filterOnType &&\n    (rootNode.listItem || 'normal') === style\n  ) {\n    return rootNode\n  }\n\n  if (!('children' in rootNode)) {\n    return undefined\n  }\n\n  const node = rootNode.children[rootNode.children.length - 1]\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : undefined\n}\n","import {isPortableTextToolkitSpan, isPortableTextToolkitTextNode} from './asserters'\nimport type {ToolkitNestedPortableTextSpan} from './types'\n\n/**\n * Returns the plain-text representation of a\n * {@link ToolkitNestedPortableTextSpan | toolkit-specific Portable Text span}.\n *\n * Useful if you have a subset of nested nodes and want the text from just those,\n * instead of for the entire Portable Text block.\n *\n * @param span - Span node to get text from (Portable Text toolkit specific type)\n * @returns The plain-text version of the span\n */\nexport function spanToPlainText(span: ToolkitNestedPortableTextSpan): string {\n  let text = ''\n  span.children.forEach((current) => {\n    if (isPortableTextToolkitTextNode(current)) {\n      text += current.text\n    } else if (isPortableTextToolkitSpan(current)) {\n      text += spanToPlainText(current)\n    }\n  })\n  return text\n}\n","import type {\n  ArbitraryTypedObject,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n} from '@portabletext/types'\n\n/**\n * List nesting mode for HTML, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_HTML = 'html'\n\n/**\n * List nesting mode for direct, nested lists, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_DIRECT = 'direct'\n\n/**\n * List nesting mode, see the {@link nestLists | `nestLists()` function}\n */\nexport type ToolkitListNestMode = 'html' | 'direct'\n\n/**\n * Toolkit-specific type representing a nested list\n *\n * See the `nestLists()` function for more info\n */\nexport type ToolkitPortableTextList = ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList\n\n/**\n * Toolkit-specific type representing a nested list in HTML mode, where deeper lists are nested\n * inside of the _list items_, eg `<ul><li>Some text<ul><li>Deeper</li></ul></li></ul>`\n */\nexport interface ToolkitPortableTextHtmlList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes will appear as children of the _list items_\n   */\n  mode: 'html'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - toolkit-specific list items which can themselves hold deeper lists\n   */\n  children: ToolkitPortableTextListItem[]\n}\n\n/**\n * Toolkit-specific type representing a nested list in \"direct\" mode, where deeper lists are nested\n * inside of the lists children, alongside other blocks.\n */\nexport interface ToolkitPortableTextDirectList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes can appear as direct children\n   */\n  mode: 'direct'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - either portable text list items, or another, deeper list\n   */\n  children: (PortableTextListItemBlock | ToolkitPortableTextDirectList)[]\n}\n\n/**\n * Toolkit-specific type representing a list item block, but where the children can be another list\n */\nexport interface ToolkitPortableTextListItem\n  extends PortableTextListItemBlock<\n    PortableTextMarkDefinition,\n    PortableTextSpan | ToolkitPortableTextList\n  > {}\n\n/**\n * Toolkit-specific type representing a text node, used when nesting spans.\n *\n * See the {@link buildMarksTree | `buildMarksTree()` function}\n */\nexport interface ToolkitTextNode {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@text'\n\n  /**\n   * The actual string value of the text node\n   */\n  text: string\n}\n\n/**\n * Toolkit-specific type representing a portable text span that can hold other spans.\n * In this type, each span only has a single mark, instead of an array of them.\n */\nexport interface ToolkitNestedPortableTextSpan<\n  M extends PortableTextMarkDefinition = PortableTextMarkDefinition,\n> {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@span'\n\n  /**\n   * Unique key for this span\n   */\n  _key?: string\n\n  /**\n   * Holds the value (definition) of the mark in the case of annotations.\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markDef?: M\n\n  /**\n   * The key of the mark definition (in the case of annotations).\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markKey?: string\n\n  /**\n   * Type of the mark. For annotations, this is the `_type` property of the value.\n   * For decorators, it will hold the name of the decorator (strong, em or similar).\n   */\n  markType: string\n\n  /**\n   * Child nodes of this span. Can be toolkit-specific text nodes, nested spans\n   * or any inline object type.\n   */\n  children: (ToolkitTextNode | ToolkitNestedPortableTextSpan | ArbitraryTypedObject)[]\n}\n","import type {TypedObject} from '@portabletext/types'\n\nimport type {PortableTextMarkComponent} from '../types'\n\ninterface DefaultLink extends TypedObject {\n  _type: 'link'\n  href: string\n}\n\nconst link: PortableTextMarkComponent<DefaultLink> = ({children, value}) => (\n  <a href={value?.href}>{children}</a>\n)\n\nconst underlineStyle = {textDecoration: 'underline'}\n\nexport const defaultMarks: Record<string, PortableTextMarkComponent | undefined> = {\n  em: ({children}) => <em>{children}</em>,\n  strong: ({children}) => <strong>{children}</strong>,\n  code: ({children}) => <code>{children}</code>,\n  underline: ({children}) => <span style={underlineStyle}>{children}</span>,\n  'strike-through': ({children}) => <del>{children}</del>,\n  link,\n}\n","const getTemplate = (type: string, prop: string): string =>\n  `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`\n\nexport const unknownTypeWarning = (typeName: string): string =>\n  getTemplate(`block type \"${typeName}\"`, 'types')\n\nexport const unknownMarkWarning = (markType: string): string =>\n  getTemplate(`mark type \"${markType}\"`, 'marks')\n\nexport const unknownBlockStyleWarning = (blockStyle: string): string =>\n  getTemplate(`block style \"${blockStyle}\"`, 'block')\n\nexport const unknownListStyleWarning = (listStyle: string): string =>\n  getTemplate(`list style \"${listStyle}\"`, 'list')\n\nexport const unknownListItemStyleWarning = (listStyle: string): string =>\n  getTemplate(`list item style \"${listStyle}\"`, 'listItem')\n\nexport function printWarning(message: string): void {\n  // oxlint-disable-next-line no-console\n  console.warn(message)\n}\n","import type {PortableTextReactComponents} from '../types'\nimport {unknownTypeWarning} from '../warnings'\n\nconst hidden = {display: 'none'}\n\nexport const DefaultUnknownType: PortableTextReactComponents['unknownType'] = ({\n  value,\n  isInline,\n}) => {\n  const warning = unknownTypeWarning(value._type)\n  return isInline ? <span style={hidden}>{warning}</span> : <div style={hidden}>{warning}</div>\n}\n\nexport const DefaultUnknownMark: PortableTextReactComponents['unknownMark'] = ({\n  markType,\n  children,\n}) => {\n  return <span className={`unknown__pt__mark__${markType}`}>{children}</span>\n}\n\nexport const DefaultUnknownBlockStyle: PortableTextReactComponents['unknownBlockStyle'] = ({\n  children,\n}) => {\n  return <p>{children}</p>\n}\n\nexport const DefaultUnknownList: PortableTextReactComponents['unknownList'] = ({children}) => {\n  return <ul>{children}</ul>\n}\n\nexport const DefaultUnknownListItem: PortableTextReactComponents['unknownListItem'] = ({\n  children,\n}) => {\n  return <li>{children}</li>\n}\n","import type {PortableTextBlockStyle} from '@portabletext/types'\nimport type {JSX} from 'react'\n\nimport type {PortableTextBlockComponent, PortableTextReactComponents} from '../types'\nimport {DefaultListItem, defaultLists} from './list'\nimport {defaultMarks} from './marks'\nimport {\n  DefaultUnknownBlockStyle,\n  DefaultUnknownList,\n  DefaultUnknownListItem,\n  DefaultUnknownMark,\n  DefaultUnknownType,\n} from './unknown'\n\nexport const DefaultHardBreak = (): JSX.Element => <br />\n\nexport const defaultBlockStyles: Record<\n  PortableTextBlockStyle,\n  PortableTextBlockComponent | undefined\n> = {\n  normal: ({children}) => <p>{children}</p>,\n  blockquote: ({children}) => <blockquote>{children}</blockquote>,\n  h1: ({children}) => <h1>{children}</h1>,\n  h2: ({children}) => <h2>{children}</h2>,\n  h3: ({children}) => <h3>{children}</h3>,\n  h4: ({children}) => <h4>{children}</h4>,\n  h5: ({children}) => <h5>{children}</h5>,\n  h6: ({children}) => <h6>{children}</h6>,\n}\n\nexport const defaultComponents: PortableTextReactComponents = {\n  types: {},\n\n  block: defaultBlockStyles,\n  marks: defaultMarks,\n  list: defaultLists,\n  listItem: DefaultListItem,\n  hardBreak: DefaultHardBreak,\n\n  unknownType: DefaultUnknownType,\n  unknownMark: DefaultUnknownMark,\n  unknownList: DefaultUnknownList,\n  unknownListItem: DefaultUnknownListItem,\n  unknownBlockStyle: DefaultUnknownBlockStyle,\n}\n","import type {PortableTextListComponent, PortableTextListItemComponent} from '../types'\n\nexport const defaultLists: Record<'number' | 'bullet', PortableTextListComponent> = {\n  number: ({children}) => <ol>{children}</ol>,\n  bullet: ({children}) => <ul>{children}</ul>,\n}\n\nexport const DefaultListItem: PortableTextListItemComponent = ({children}) => <li>{children}</li>\n","import type {PortableTextComponents, PortableTextReactComponents} from '../types'\n\nexport function mergeComponents(\n  parent: PortableTextReactComponents,\n  overrides: PortableTextComponents,\n): PortableTextReactComponents {\n  const {\n    block: _block,\n    list: _list,\n    listItem: _listItem,\n    marks: _marks,\n    types: _types,\n    ...rest\n  } = overrides\n  // @todo figure out how to not `as ...` these\n  return {\n    ...parent,\n    block: mergeDeeply(parent, overrides, 'block') as PortableTextReactComponents['block'],\n    list: mergeDeeply(parent, overrides, 'list') as PortableTextReactComponents['list'],\n    listItem: mergeDeeply(parent, overrides, 'listItem') as PortableTextReactComponents['listItem'],\n    marks: mergeDeeply(parent, overrides, 'marks') as PortableTextReactComponents['marks'],\n    types: mergeDeeply(parent, overrides, 'types') as PortableTextReactComponents['types'],\n    ...rest,\n  }\n}\n\nfunction mergeDeeply(\n  parent: PortableTextReactComponents,\n  overrides: PortableTextComponents,\n  key: 'block' | 'list' | 'listItem' | 'marks' | 'types',\n): PortableTextReactComponents[typeof key] {\n  const override = overrides[key]\n  const parentVal = parent[key]\n\n  if (typeof override === 'function') {\n    return override\n  }\n\n  if (override && typeof parentVal === 'function') {\n    return override\n  }\n\n  if (override) {\n    return {...parentVal, ...override} as PortableTextReactComponents[typeof key]\n  }\n\n  return parentVal\n}\n","import type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from '@portabletext/toolkit'\nimport {\n  buildMarksTree,\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n  isPortableTextToolkitList,\n  isPortableTextToolkitSpan,\n  isPortableTextToolkitTextNode,\n  LIST_NEST_MODE_HTML,\n  nestLists,\n  spanToPlainText,\n} from '@portabletext/toolkit'\nimport type {PortableTextBlock, PortableTextListItemBlock, TypedObject} from '@portabletext/types'\nimport {type JSX, type ReactNode, useMemo} from 'react'\n\nimport {defaultComponents} from './components/defaults'\nimport {mergeComponents} from './components/merge'\nimport type {\n  MissingComponentHandler,\n  NodeRenderer,\n  PortableTextProps,\n  PortableTextReactComponents,\n  ReactPortableTextList,\n  Serializable,\n  SerializedBlock,\n} from './types'\nimport {\n  printWarning,\n  unknownBlockStyleWarning,\n  unknownListItemStyleWarning,\n  unknownListStyleWarning,\n  unknownMarkWarning,\n  unknownTypeWarning,\n} from './warnings'\n\nexport function PortableText<B extends TypedObject = PortableTextBlock>({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning,\n}: PortableTextProps<B>): JSX.Element {\n  const handleMissingComponent = missingComponentHandler || noop\n  const blocks = Array.isArray(input) ? input : [input]\n  const nested = nestLists(blocks, listNestingMode || LIST_NEST_MODE_HTML)\n\n  const components = useMemo(() => {\n    return componentOverrides\n      ? mergeComponents(defaultComponents, componentOverrides)\n      : defaultComponents\n  }, [componentOverrides])\n\n  const renderNode = useMemo(\n    () => getNodeRenderer(components, handleMissingComponent),\n    [components, handleMissingComponent],\n  )\n  const rendered = nested.map((node, index) =>\n    renderNode({node: node, index, isInline: false, renderNode}),\n  )\n\n  return <>{rendered}</>\n}\n\nconst getNodeRenderer = (\n  components: PortableTextReactComponents,\n  handleMissingComponent: MissingComponentHandler,\n): NodeRenderer => {\n  function renderNode<N extends TypedObject>(options: Serializable<N>): ReactNode {\n    const {node, index, isInline} = options\n    const key = node._key || `node-${index}`\n\n    if (isPortableTextToolkitList(node)) {\n      return renderList(node, index, key)\n    }\n\n    if (isPortableTextListItemBlock(node)) {\n      return renderListItem(node, index, key)\n    }\n\n    if (isPortableTextToolkitSpan(node)) {\n      return renderSpan(node, index, key)\n    }\n\n    if (hasCustomComponentForNode(node)) {\n      return renderCustomBlock(node, index, key, isInline)\n    }\n\n    if (isPortableTextBlock(node)) {\n      return renderBlock(node, index, key, isInline)\n    }\n\n    if (isPortableTextToolkitTextNode(node)) {\n      return renderText(node, key)\n    }\n\n    return renderUnknownType(node, index, key, isInline)\n  }\n\n  function hasCustomComponentForNode(node: TypedObject): boolean {\n    return node._type in components.types\n  }\n\n  function renderListItem(node: PortableTextListItemBlock, index: number, key: string) {\n    const tree = serializeBlock({node, index, isInline: false, renderNode})\n    const renderer = components.listItem\n    const handler = typeof renderer === 'function' ? renderer : renderer[node.listItem]\n    const Li = handler || components.unknownListItem\n\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: 'listItemStyle',\n      })\n    }\n\n    let children = tree.children\n    if (node.style && node.style !== 'normal') {\n      // Wrap any other style in whatever the block serializer says to use\n      const {listItem: _listItem, ...blockNode} = node\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: false,\n        renderNode,\n      })\n    }\n\n    return (\n      <Li key={key} value={node} index={index} isInline={false} renderNode={renderNode}>\n        {children}\n      </Li>\n    )\n  }\n\n  function renderList(node: ReactPortableTextList, index: number, key: string) {\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child._key ? child : {...child, _key: `li-${index}-${childIndex}`},\n        index: childIndex,\n        isInline: false,\n        renderNode,\n      }),\n    )\n\n    const component = components.list\n    const handler = typeof component === 'function' ? component : component[node.listItem]\n    const List = handler || components.unknownList\n\n    if (List === components.unknownList) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListStyleWarning(style), {\n        nodeType: 'listStyle',\n        type: style,\n      })\n    }\n\n    return (\n      <List key={key} value={node} index={index} isInline={false} renderNode={renderNode}>\n        {children}\n      </List>\n    )\n  }\n\n  function renderSpan(node: ToolkitNestedPortableTextSpan, _index: number, key: string) {\n    const {markDef, markType, markKey} = node\n    const Span = components.marks[markType] || components.unknownMark\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child,\n        index: childIndex,\n        isInline: true,\n        renderNode,\n      }),\n    )\n\n    if (Span === components.unknownMark) {\n      handleMissingComponent(unknownMarkWarning(markType), {\n        nodeType: 'mark',\n        type: markType,\n      })\n    }\n\n    return (\n      <Span\n        key={key}\n        text={spanToPlainText(node)}\n        value={markDef}\n        markType={markType}\n        markKey={markKey}\n        renderNode={renderNode}\n      >\n        {children}\n      </Span>\n    )\n  }\n\n  function renderBlock(node: PortableTextBlock, index: number, key: string, isInline: boolean) {\n    const {_key, ...props} = serializeBlock({\n      node,\n      index,\n      isInline,\n      renderNode,\n    })\n    const style = props.node.style || 'normal'\n    const handler =\n      typeof components.block === 'function' ? components.block : components.block[style]\n    const Block = handler || components.unknownBlockStyle\n\n    if (Block === components.unknownBlockStyle) {\n      handleMissingComponent(unknownBlockStyleWarning(style), {\n        nodeType: 'blockStyle',\n        type: style,\n      })\n    }\n\n    return <Block key={key} {...props} value={props.node} renderNode={renderNode} />\n  }\n\n  function renderText(node: ToolkitTextNode, key: string) {\n    if (node.text === '\\n') {\n      const HardBreak = components.hardBreak\n      return HardBreak ? <HardBreak key={key} /> : '\\n'\n    }\n\n    return node.text\n  }\n\n  function renderUnknownType(node: TypedObject, index: number, key: string, isInline: boolean) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode,\n    }\n\n    handleMissingComponent(unknownTypeWarning(node._type), {\n      nodeType: 'block',\n      type: node._type,\n    })\n\n    const UnknownType = components.unknownType\n    return <UnknownType key={key} {...nodeOptions} />\n  }\n\n  function renderCustomBlock(node: TypedObject, index: number, key: string, isInline: boolean) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode,\n    }\n\n    const Node = components.types[node._type]\n    return Node ? <Node key={key} {...nodeOptions} /> : null\n  }\n\n  return renderNode\n}\n\nfunction serializeBlock(options: Serializable<PortableTextBlock>): SerializedBlock {\n  const {node, index, isInline, renderNode} = options\n  const tree = buildMarksTree(node)\n  const children = tree.map((child, i) =>\n    renderNode({node: child, isInline: true, index: i, renderNode}),\n  )\n\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node,\n  }\n}\n\nfunction noop() {\n  // Intentional noop\n}\n","import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextMarkDefinition,\n} from '@portabletext/types'\n\nimport {isPortableTextSpan} from './asserters'\nimport {sortMarksByOccurences} from './sortMarksByOccurences'\nimport type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from './types'\n\n/**\n * Takes a Portable Text block and returns a nested tree of nodes optimized for rendering\n * in HTML-like environments where you want marks/annotations to be nested inside of eachother.\n * For instance, a naive span-by-span rendering might yield:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded and </strong>\n * <em><strong>italicized text</strong></em>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a>\n *   and some bolded and <em>italicized text</em>\n * </strong>\n * ```\n *\n * Note that since \"native\" Portable Text spans cannot be nested,\n * this function returns an array of \"toolkit specific\" types:\n * {@link ToolkitTextNode | `@text`} and {@link ToolkitNestedPortableTextSpan | `@span` }.\n *\n * The toolkit-specific type can hold both types, as well as any arbitrary inline objects,\n * creating an actual tree.\n *\n * @param block - The Portable Text block to create a tree of nodes from\n * @returns Array of (potentially) nested spans, text nodes and/or arbitrary inline objects\n */\nexport function buildMarksTree<M extends PortableTextMarkDefinition = PortableTextMarkDefinition>(\n  block: PortableTextBlock<M>,\n): (ToolkitNestedPortableTextSpan<M> | ToolkitTextNode | ArbitraryTypedObject)[] {\n  const {children} = block\n  const markDefs = block.markDefs ?? []\n  if (!children || !children.length) {\n    return []\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences)\n\n  const rootNode: ToolkitNestedPortableTextSpan<M> = {\n    _type: '@span',\n    children: [],\n    markType: '<unknown>',\n  }\n\n  let nodeStack: ToolkitNestedPortableTextSpan<M>[] = [rootNode]\n\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i]\n    if (!span) {\n      continue\n    }\n\n    const marksNeeded = sortedMarks[i] || []\n    let pos = 1\n\n    // Start at position one. Root is always plain and should never be removed\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = nodeStack[pos]?.markKey || ''\n        const index = marksNeeded.indexOf(mark)\n\n        if (index === -1) {\n          break\n        }\n\n        marksNeeded.splice(index, 1)\n      }\n    }\n\n    // Keep from beginning to first miss\n    nodeStack = nodeStack.slice(0, pos)\n\n    // Add needed nodes\n    let currentNode = nodeStack[nodeStack.length - 1]\n    if (!currentNode) {\n      continue\n    }\n\n    for (const markKey of marksNeeded) {\n      const markDef = markDefs?.find((def) => def._key === markKey)\n      const markType = markDef ? markDef._type : markKey\n      const node: ToolkitNestedPortableTextSpan<M> = {\n        _type: '@span',\n        _key: span._key,\n        children: [],\n        markDef,\n        markType,\n        markKey,\n      }\n\n      currentNode.children.push(node)\n      nodeStack.push(node)\n      currentNode = node\n    }\n\n    // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n    if (isPortableTextSpan(span)) {\n      const lines = span.text.split('\\n')\n      for (let line = lines.length; line-- > 1; ) {\n        lines.splice(line, 0, '\\n')\n      }\n\n      currentNode.children = currentNode.children.concat(\n        lines.map((text) => ({_type: '@text', text})),\n      )\n    } else {\n      // This is some other inline object, not a text span\n      currentNode.children = currentNode.children.concat(span)\n    }\n  }\n\n  return rootNode.children\n}\n","// src/pages/SinglePostPage.js\r\nimport React, { useState, useEffect } from 'react';\r\nimport { useParams, Link } from 'react-router-dom';\r\nimport { Helmet } from 'react-helmet-async';\r\nimport { PortableText } from '@portabletext/react';\r\nimport { useTranslation } from '../contexts/LanguageContext';\r\nimport { client, urlFor } from '../client';\r\nimport { motion } from 'framer-motion';\r\n\r\n// --- Helper function to format the date ---\r\nfunction formatDate(date) {\r\n  return new Date(date).toLocaleDateString('en-US', {\r\n    year: 'numeric',\r\n    month: 'long',\r\n    day: 'numeric',\r\n  });\r\n}\r\n\r\n// --- Main Component ---\r\nfunction SinglePostPage() {\r\n  const { t } = useTranslation();\r\n  \r\n  // State for post, comments, loading, and errors\r\n  const [postData, setPostData] = useState(null);\r\n  const [comments, setComments] = useState(null);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n\r\n  // State for the comment form\r\n  const [formData, setFormData] = useState({ name: '', comment: '' });\r\n  const [isSubmitted, setIsSubmitted] = useState(false);\r\n  const [isSubmitting, setIsSubmitting] = useState(false);\r\n\r\n  const { slug } = useParams(); // 1. Get the \"slug\" from the URL\r\n\r\n  // 2. Fetch the correct blog post\r\n  useEffect(() => {\r\n    const postQuery = `*[_type == \"post\" && slug.current == $slug][0]{\r\n      _id,\r\n      title,\r\n      \"slug\": slug.current,\r\n      mainImage,\r\n      publishedAt,\r\n      body\r\n    }`;\r\n\r\n    setIsLoading(true);\r\n    client.fetch(postQuery, { slug })\r\n      .then((data) => {\r\n        if (data) {\r\n          setPostData(data);\r\n        } else {\r\n          setError(new Error('Post not found.'));\r\n          setIsLoading(false);\r\n        }\r\n      })\r\n      .catch((err) => {\r\n        console.error('Error fetching post:', err);\r\n        setError(err);\r\n        setIsLoading(false);\r\n      });\r\n  }, [slug]);\r\n\r\n  // 3. Fetch the comments *after* the post data has been loaded\r\n  useEffect(() => {\r\n    if (postData) {\r\n      const commentsQuery = `*[_type == \"comment\" && approved == true && post._ref == $postId]{\r\n        _id,\r\n        name,\r\n        comment,\r\n        _createdAt\r\n      } | order(_createdAt asc)`;\r\n\r\n      client.fetch(commentsQuery, { postId: postData._id })\r\n        .then((data) => {\r\n          setComments(data);\r\n          setIsLoading(false);\r\n        })\r\n        .catch((err) => {\r\n          console.error('Error fetching comments:', err);\r\n          setError(err);\r\n          setIsLoading(false);\r\n        });\r\n    }\r\n  }, [postData]);\r\n\r\n  // --- Handle Form Input Change ---\r\n  const handleFormChange = (e) => {\r\n    const { name, value } = e.target;\r\n    setFormData(prevData => ({\r\n      ...prevData,\r\n      [name]: value\r\n    }));\r\n  };\r\n\r\n  // --- Handle Form Submission ---\r\n  const handleCommentSubmit = async (e) => {\r\n    e.preventDefault();\r\n    if (!formData.name || !formData.comment) return;\r\n\r\n    setIsSubmitting(true);\r\n\r\n    const submission = {\r\n      name: formData.name,\r\n      comment: formData.comment,\r\n      post: postData._id,\r\n    };\r\n\r\n    try {\r\n      const response = await fetch('http://localhost:3001/api/submit-comment', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(submission),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to submit comment');\r\n      }\r\n\r\n      setIsSubmitting(false);\r\n      setIsSubmitted(true);\r\n      setFormData({ name: '', comment: '' });\r\n\r\n    } catch (err) {\r\n      console.error('Error submitting comment:', err);\r\n      setIsSubmitting(false);\r\n    }\r\n  };\r\n\r\n  // --- Render States ---\r\n  if (isLoading) {\r\n    return (\r\n      <div className=\"flex justify-center items-center h-screen bg-white dark:bg-gray-900\">\r\n        <h1 className=\"text-3xl font-bold text-blue-600 dark:text-blue-400\">\r\n          {t('singlePost.loadingPost')}\r\n        </h1>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (error) {\r\n    return (\r\n      <div className=\"container mx-auto px-6 py-20 text-center\">\r\n        <h1 className=\"text-3xl font-bold text-red-600 dark:text-red-400\">\r\n          {t('singlePost.errorMessage')} {error.message}\r\n        </h1>\r\n        <Link to=\"/blog\" className=\"mt-4 inline-block text-blue-600 dark:text-blue-400 hover:underline\">\r\n          {t('singlePost.backToBlog')}\r\n        </Link>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (!postData) return null;\r\n\r\n  return (\r\n    <motion.div\r\n      className=\"bg-white dark:bg-gray-900\"\r\n      initial={{ opacity: 0 }}\r\n      animate={{ opacity: 1 }}\r\n      transition={{ duration: 0.5 }}\r\n    >\r\n      <Helmet>\r\n        <title>{`Nexus Solutions | ${postData.title}`}</title>\r\n        <meta name=\"description\" content={`Read the blog post: ${postData.title}`} />\r\n      </Helmet>\r\n      \r\n      {/* 1. Post Header with Image */}\r\n      <div className=\"relative h-96\">\r\n        <img\r\n          src={urlFor(postData.mainImage).width(1200).height(400).auto('format').fit('crop').url()}\r\n          alt={postData.title}\r\n          className=\"absolute inset-0 w-full h-full object-cover\"\r\n        />\r\n        <div className=\"absolute inset-0 bg-black/50\" />\r\n        <div className=\"absolute inset-0 flex flex-col justify-end p-8 md:p-12\">\r\n          <h1 className=\"text-4xl md:text-6xl font-extrabold text-white z-10\">\r\n            {postData.title}\r\n          </h1>\r\n          <p className=\"text-lg text-gray-200 z-10 mt-2\">\r\n            {t('singlePost.publishedOn')} {formatDate(postData.publishedAt)}\r\n          </p>\r\n        </div>\r\n      </div>\r\n      \r\n      {/* 2. Post Body Content */}\r\n      <div className=\"container mx-auto max-w-3xl px-6 py-12 md:py-20\">\r\n        <article className=\"prose prose-lg dark:prose-invert\r\n                            prose-headings:font-bold prose-headings:text-gray-900 dark:prose-headings:text-white\r\n                            prose-a:text-blue-600 dark:prose-a:text-blue-400\r\n                            prose-li:marker:text-blue-600 dark:prose-li:marker:text-blue-400\r\n                            prose-blockquote:border-l-blue-600 dark:prose-blockquote:border-l-blue-400\">\r\n          <PortableText value={postData.body} />\r\n        </article>\r\n      </div>\r\n      \r\n      {/* 3. Comments Section */}\r\n      <section className=\"bg-gray-50 dark:bg-gray-800 py-12 md:py-20\">\r\n        <div className=\"container mx-auto max-w-3xl px-6\">\r\n          <h2 className=\"text-3xl font-bold text-gray-900 dark:text-white mb-8\">\r\n            {t('singlePost.commentsCount')} ({comments ? comments.length : 0})\r\n          </h2>\r\n          \r\n          <div className=\"space-y-6\">\r\n            {comments && comments.length > 0 ? (\r\n              comments.map((comment) => (\r\n                <div key={comment._id} className=\"bg-white dark:bg-gray-700 p-6 rounded-lg shadow\">\r\n                  <div className=\"flex items-center mb-2\">\r\n                    <h3 className=\"text-lg font-semibold text-gray-900 dark:text-white\">\r\n                      {comment.name}\r\n                    </h3>\r\n                    <span className=\"text-sm text-gray-500 dark:text-gray-400 ml-3\">\r\n                      {formatDate(comment._createdAt)}\r\n                    </span>\r\n                  </div>\r\n                  <p className=\"text-gray-600 dark:text-gray-300\">\r\n                    {comment.comment}\r\n                  </p>\r\n                </div>\r\n              ))\r\n            ) : (\r\n              <p className=\"text-gray-600 dark:text-gray-300\">\r\n                {t('singlePost.noComments')}\r\n              </p>\r\n            )}\r\n            \r\n            {/* 4. Leave a Comment Form */}\r\n            <div className=\"pt-8\">\r\n              <h3 className=\"text-2xl font-bold text-gray-900 dark:text-white mb-4\">\r\n                {t('singlePost.leaveComment')}\r\n              </h3>\r\n\r\n              {isSubmitted ? (\r\n                <div className=\"bg-green-50 dark:bg-green-900 border border-green-300 dark:border-green-700 text-green-800 dark:text-green-200 p-4 rounded-lg\">\r\n                  {t('singlePost.thankYouMessage')}\r\n                </div>\r\n              ) : (\r\n                <form onSubmit={handleCommentSubmit} className=\"space-y-4\">\r\n                  <div>\r\n                    <label htmlFor=\"name\" className=\"block text-sm font-medium text-gray-700 dark:text-gray-300\">\r\n                      {t('singlePost.commentFormName')}\r\n                    </label>\r\n                    <input\r\n                      type=\"text\"\r\n                      name=\"name\"\r\n                      id=\"name\"\r\n                      value={formData.name}\r\n                      onChange={handleFormChange}\r\n                      className=\"mt-1 block w-full rounded-md border-gray-300 shadow-sm \r\n                                 focus:border-blue-500 focus:ring-blue-500\r\n                                 dark:bg-gray-900 dark:border-gray-600 dark:text-white\"\r\n                      required\r\n                    />\r\n                  </div>\r\n                  <div>\r\n                    <label htmlFor=\"comment\" className=\"block text-sm font-medium text-gray-700 dark:text-gray-300\">\r\n                      {t('singlePost.commentFormComment')}\r\n                    </label>\r\n                    <textarea\r\n                      name=\"comment\"\r\n                      id=\"comment\"\r\n                      rows=\"4\"\r\n                      value={formData.comment}\r\n                      onChange={handleFormChange}\r\n                      className=\"mt-1 block w-full rounded-md border-gray-300 shadow-sm \r\n                                 focus:border-blue-500 focus:ring-blue-500\r\n                                 dark:bg-gray-900 dark:border-gray-600 dark:text-white\"\r\n                      required\r\n                    ></textarea>\r\n                  </div>\r\n                  <div>\r\n                    <button\r\n                      type=\"submit\"\r\n                      disabled={isSubmitting}\r\n                      className=\"inline-flex justify-center py-2 px-4 border border-transparent shadow-sm\r\n                                 text-base font-medium rounded-lg text-white bg-blue-600\r\n                                 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500\r\n                                 transition duration-300\r\n                                 disabled:bg-gray-400 dark:disabled:bg-gray-600\"\r\n                    >\r\n                      {isSubmitting ? t('singlePost.submittingButton') : t('singlePost.submitButton')}\r\n                    </button>\r\n                  </div>\r\n                </form>\r\n              )}\r\n            </div>\r\n            \r\n          </div>\r\n        </div>\r\n      </section>\r\n    </motion.div>\r\n  );\r\n}\r\n\r\nexport default SinglePostPage;","// src/client.js\r\nimport { createClient } from '@sanity/client';\r\nimport imageUrlBuilder from '@sanity/image-url';\r\n\r\n// This is your connection details\r\nexport const client = createClient({\r\n  projectId: \"m4s7pq0x\", //  Paste your projectId here\r\n  dataset: \"production\",\r\n  useCdn: true, // `false` if you want to ensure fresh data\r\n  apiVersion: '2023-05-03', // Use a current date\r\n});\r\n\r\n// This is a helper function to get image URLs\r\nconst builder = imageUrlBuilder(client);\r\nexport const urlFor = (source) => builder.image(source);"],"names":["isPortableTextSpan","node","_type","text","marks","Array","isArray","every","mark","isPortableTextBlock","markDefs","def","_key","children","child","isPortableTextListItemBlock","block","listItem","level","isPortableTextToolkitList","isPortableTextToolkitSpan","span","isPortableTextToolkitTextNode","knownDecorators","sortMarksByOccurences","index","blockChildren","length","slice","occurences","forEach","siblingIndex","sibling","indexOf","sort","markA","markB","aOccurences","bOccurences","aKnownPos","bKnownPos","localeCompare","sortMarks","blockMatchesList","list","listFromBlock","mode","concat","findListMatching","rootNode","matching","style","filterOnType","spanToPlainText","current","underlineStyle","textDecoration","getTemplate","type","prop","unknownTypeWarning","typeName","printWarning","message","console","warn","hidden","display","defaultComponents","types","normal","_ref13","jsx","blockquote","_ref14","h1","_ref15","h2","_ref16","h3","_ref17","h4","_ref18","h5","_ref19","h6","_ref20","em","_ref5","strong","_ref6","code","_ref7","underline","_ref8","_ref9","link","_ref4","value","href","number","_ref","bullet","_ref2","_ref3","hardBreak","DefaultHardBreak","unknownType","_ref0","isInline","warning","unknownMark","_ref1","markType","className","unknownList","_ref11","unknownListItem","_ref12","unknownBlockStyle","_ref10","mergeDeeply","parent","overrides","key","override","parentVal","_objectSpread","PortableText","_ref21","input","components","componentOverrides","listNestingMode","onMissingComponent","missingComponentHandler","handleMissingComponent","noop","nested","blocks","tree","currentList","i","push","newList","lastListItem","newLastChild","matchingBranch","match","nestLists","useMemo","_block","_list","_listItem","_marks","_types","rest","_objectWithoutProperties","_excluded","mergeComponents","renderNode","getNodeRenderer","rendered","map","Fragment","options","childIndex","component","List","nodeType","renderList","serializeBlock","renderer","Li","_excluded2","renderListItem","_index","markDef","markKey","Span","unknownMarkWarning","renderSpan","hasCustomComponentForNode","nodeOptions","Node","renderCustomBlock","_serializeBlock","props","_excluded3","Block","blockStyle","renderBlock","HardBreak","renderText","UnknownType","renderUnknownType","_block$markDefs","sortedMarks","nodeStack","marksNeeded","pos","_nodeStack$pos","splice","currentNode","find","lines","split","line","buildMarksTree","formatDate","date","Date","toLocaleDateString","year","month","day","t","useTranslation","postData","setPostData","useState","comments","setComments","isLoading","setIsLoading","error","setError","formData","setFormData","name","comment","isSubmitted","setIsSubmitted","isSubmitting","setIsSubmitting","slug","useParams","useEffect","client","fetch","then","data","Error","catch","err","commentsQuery","postId","_id","handleFormChange","e","target","prevData","_jsx","_jsxs","Link","to","motion","div","initial","opacity","animate","transition","duration","Helmet","title","content","src","urlFor","mainImage","width","height","auto","fit","url","alt","publishedAt","body","_createdAt","onSubmit","async","preventDefault","submission","post","method","headers","JSON","stringify","ok","htmlFor","id","onChange","required","rows","disabled","createClient","projectId","dataset","useCdn","apiVersion","builder","imageUrlBuilder","source","image"],"sourceRoot":""}