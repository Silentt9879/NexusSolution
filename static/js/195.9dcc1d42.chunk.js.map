{"version":3,"file":"static/js/195.9dcc1d42.chunk.js","mappings":"4MAIA,MAAMA,EAAsB,CACxB,8BAA+B,CAC3B,CAAEC,KAAM,EAAGC,MAAO,uBAAwBC,YAAa,oDACvD,CAAEF,KAAM,EAAGC,MAAO,uBAAwBC,YAAa,2DACvD,CAAEF,KAAM,EAAGC,MAAO,oBAAqBC,YAAa,0DACpD,CAAEF,KAAM,EAAGC,MAAO,8BAA+BC,YAAa,6DAC9D,CAAEF,KAAM,EAAGC,MAAO,sBAAuBC,YAAa,8DAE1D,8BAA+B,CAC3B,CAAEF,KAAM,EAAGC,MAAO,wBAAyBC,YAAa,wEACxD,CAAEF,KAAM,EAAGC,MAAO,sBAAuBC,YAAa,8DACtD,CAAEF,KAAM,EAAGC,MAAO,4BAA6BC,YAAa,gEAC5D,CAAEF,KAAM,EAAGC,MAAO,4BAA6BC,YAAa,yDAEhE,kBAAmB,CACf,CAAEF,KAAM,EAAGC,MAAO,+BAAgCC,YAAa,yDAC/D,CAAEF,KAAM,EAAGC,MAAO,oBAAqBC,YAAa,4DACpD,CAAEF,KAAM,EAAGC,MAAO,2BAA4BC,YAAa,0EAC3D,CAAEF,KAAM,EAAGC,MAAO,yBAA0BC,YAAa,4EA+BjE,EA1BqBC,IAAsB,IAArB,YAAEC,GAAaD,EACjC,MAAME,EAAUN,EAAoBK,IAAgB,GAGpD,OACIE,EAAAA,EAAAA,KAAA,OAAKC,UAAU,iEAAgEC,SAC1EH,EAAQI,IAAKC,IACVC,EAAAA,EAAAA,MAAA,OAEIJ,UAAU,2EAA0EC,SAAA,EAEpFG,EAAAA,EAAAA,MAAA,QAAMJ,UAAU,mDAAkDC,SAAA,CAC7DE,EAAKV,KAAK,QAEfM,EAAAA,EAAAA,KAAA,MAAIC,UAAU,2DAA0DC,SACnEE,EAAKT,SAEVK,EAAAA,EAAAA,KAAA,KAAGC,UAAU,2CAA0CC,SAClDE,EAAKR,gBAVLQ,EAAKV,UCzBxBY,EAAU,CACd,+BACEN,EAAAA,EAAAA,KAAA,OAAKO,MAAM,6BAA6BC,KAAK,OAAOC,QAAQ,YAAYC,YAAa,IAAKC,OAAO,eAAeV,UAAU,YAAWC,UACnIF,EAAAA,EAAAA,KAAA,QAAMY,cAAc,QAAQC,eAAe,QAAQC,EAAE,2EAGzD,+BACEd,EAAAA,EAAAA,KAAA,OAAKO,MAAM,6BAA6BC,KAAK,OAAOC,QAAQ,YAAYC,YAAa,IAAKC,OAAO,eAAeV,UAAU,YAAWC,UACnIF,EAAAA,EAAAA,KAAA,QAAMY,cAAc,QAAQC,eAAe,QAAQC,EAAE,wIAGzD,mBACEd,EAAAA,EAAAA,KAAA,OAAKO,MAAM,6BAA6BC,KAAK,OAAOC,QAAQ,YAAYC,YAAa,IAAKC,OAAO,eAAeV,UAAU,YAAWC,UACnIF,EAAAA,EAAAA,KAAA,QAAMY,cAAc,QAAQC,eAAe,QAAQC,EAAE,4KAMrDC,EAAiB,CAAEC,OAAQ,CAAEC,EAAG,GAAIC,QAAS,GAAKC,QAAS,CAAEF,EAAG,EAAGC,QAAS,EAAGE,WAAY,CAAEC,SAAU,MAC7G,SAASC,EAAgBzB,GAAuB,IAAtB,SAAEK,EAAQ,MAAEqB,GAAO1B,EAC3C,MAAO2B,EAAKC,IAAUC,EAAAA,EAAAA,IAAU,CAAEC,aAAa,EAAMC,UAAW,KAC1DC,EAAe,CACnBb,OAAQ,CAAEc,GAAI,GAAIZ,QAAS,GAC3BC,QAAS,CAAEW,EAAG,EAAGZ,QAAS,EAAGE,WAAY,CAAEC,SAAU,GAAKU,MAAe,GAARR,KAEnE,OACEvB,EAAAA,EAAAA,KAACgC,EAAAA,EAAOC,IAAG,CAACT,IAAKA,EAAKU,QAAQ,SAASC,QAASV,EAAS,UAAY,SAAUW,SAAUP,EAAa3B,SACnGA,GAGP,CAkIA,QA/HA,WACE,MAAOmC,EAAUC,IAAeC,EAAAA,EAAAA,UAAS,OAClCC,EAAWC,IAAgBF,EAAAA,EAAAA,WAAS,IACpCG,EAAOC,IAAYJ,EAAAA,EAAAA,UAAS,MAgEnC,OA9DAK,EAAAA,EAAAA,WAAU,KAGRC,EAAAA,EAAOC,MADO,qEAEXC,KAAMC,IACLV,EAAYU,GACZP,GAAa,KAEdQ,MAAOC,IACNC,QAAQT,MAAM,2BAA4BQ,GAC1CP,EAASO,GACTT,GAAa,MAEhB,KAkDDpC,EAAAA,EAAAA,MAAA,OAAAH,SAAA,EACEG,EAAAA,EAAAA,MAAC+C,EAAAA,GAAM,CAAAlD,SAAA,EACLF,EAAAA,EAAAA,KAAA,SAAAE,SAAO,oCACPF,EAAAA,EAAAA,KAAA,QACEqD,KAAK,cACLC,QAAQ,wHAKZjD,EAAAA,EAAAA,MAAC2B,EAAAA,EAAOC,IAAG,CACThC,UAAU,gGAGViC,QAAQ,SACRC,QAAQ,UACRC,SAAUrB,EAAeb,SAAA,EAEzBF,EAAAA,EAAAA,KAAA,MAAIC,UAAU,oEAAmEC,SAAC,kBAGlFF,EAAAA,EAAAA,KAAA,KAAGC,UAAU,6EAA4EC,SAAC,2EAM5FF,EAAAA,EAAAA,KAAA,WAASC,UAAU,2FAE4CC,UAC7DF,EAAAA,EAAAA,KAAA,OAAKC,UAAU,yBAAwBC,SA7EvCsC,GACKxC,EAAAA,EAAAA,KAAA,KAAGC,UAAU,uDAAsDC,SAAC,wBAEzEwC,GAEA1C,EAAAA,EAAAA,KAAA,OAAKC,UAAU,uDAAsDC,UACnEF,EAAAA,EAAAA,KAAA,KAAGC,UAAU,yCAAwCC,SAAC,0DAO1DG,EAAAA,EAAAA,MAAA,OAAKJ,UAAU,aAAYC,SAAA,CAAC,IACzBmC,GAAYA,EAASlC,IAAI,CAACoD,EAAShC,KAClClB,EAAAA,EAAAA,MAACiB,EAAgB,CAAoBC,MAAOA,EAAMrB,SAAA,EAEhDG,EAAAA,EAAAA,MAAA,OAAKJ,UAAU,8CAA6CC,SAAA,EAC1DF,EAAAA,EAAAA,KAAA,OAAKC,UAAU,kGACqDC,SACjEI,EAAQiD,EAAQC,SAEnBnD,EAAAA,EAAAA,MAAA,OAAAH,SAAA,EACEF,EAAAA,EAAAA,KAAA,MAAIC,UAAU,mDAAkDC,SAC7DqD,EAAQ5D,SAEXK,EAAAA,EAAAA,KAAA,KAAGC,UAAU,gDAA+CC,SACzDqD,EAAQ3D,qBAMfS,EAAAA,EAAAA,MAAA,OAAKJ,UAAU,4DAA2DC,SAAA,EACtEG,EAAAA,EAAAA,MAAA,MAAIJ,UAAU,2DAA0DC,SAAA,CAAC,mBACpDqD,EAAQ5D,UAG7BK,EAAAA,EAAAA,KAACyD,EAAY,CAAC3D,YAAayD,EAAQC,YAvBlBD,EAAQC,eAoEnCxD,EAAAA,EAAAA,KAAA,WAASC,UAAU,+EAE4CC,UAC3DG,EAAAA,EAAAA,MAAA,OAAKJ,UAAU,2CAA0CC,SAAA,EACvDF,EAAAA,EAAAA,KAAA,MAAIC,UAAU,iDAAgDC,SAAC,6BAG/DF,EAAAA,EAAAA,KAAA,KAAGC,UAAU,+CAA8CC,SAAC,iEAG5DF,EAAAA,EAAAA,KAAC0D,EAAAA,GAAI,CACHC,GAAG,YACH1D,UAAU,kIACgDC,SAC3D,wBAOb,C,wECpKO,MAAM2C,GAASe,EAAAA,EAAAA,IAAa,CACjCC,UAAW,WACXC,QAAS,aACTC,QAAQ,EACRC,WAAY,eAIRC,EAAUC,IAAgBrB,GACnBsB,EAAUC,GAAWH,EAAQI,MAAMD,E,8MCA5CE,E,uJAZEC,EAAc,IAAIC,IASlBC,EAA+C,IAAIC,QACrDC,EAAS,EA+BN,SAASC,EAAYC,GAC1B,OAAOC,OAAOC,KAAKF,GAChBG,OACAC,OACEC,QAA2D,IAAnDL,EAAQK,IAElB/E,IAAK+E,IACJ,MAAO,GAAPC,OAAUD,EAAG,KAAAC,OACH,SAARD,GArBWE,EAsBGP,EAAQO,OApBxBX,EAAQY,IAAID,KAChBT,GAAU,EACVF,EAAQa,IAAIF,EAAMT,EAAOY,aAFKd,EAAQe,IAAIJ,IADxB,IAsBRP,EAAQK,IAvBpB,IAAmBE,IA0BdG,UACL,CA2DO,SAASE,EACdC,EACAC,GAGA,IAFAd,EAAAe,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAoC,CAAC,EACrCG,EAAAH,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAiBtB,EAEjB,GACyC,qBAAhC0B,OAAOC,2BACK,IAAnBF,EACA,CACA,MAAMG,EAASR,EAAQS,wBAWvB,OAVAR,EAASI,EAAgB,CACvBK,eAAgBL,EAChBM,OAAQX,EACRY,kBAC+B,kBAAtBzB,EAAQjD,UAAyBiD,EAAQjD,UAAY,EAC9D2E,KAAM,EACNC,mBAAoBN,EACpBO,iBAAkBP,EAClBQ,WAAYR,IAEP,MAGT,CAEA,MAAM,GAAES,EAAA,SAAIC,EAAA,SAAUC,GAnFxB,SAAwBhC,GAEtB,MAAM8B,EAAK/B,EAAYC,GACvB,IAAIiC,EAAWvC,EAAYiB,IAAImB,GAE/B,IAAKG,EAAU,CAEb,MAAMD,EAAW,IAAIrC,IACrB,IAAIuC,EAEJ,MAAMH,EAAW,IAAIX,qBAAsBe,IACzCA,EAAQC,QAASC,IAtEvB,IAAAC,EAyEQ,MAAM1F,EACJyF,EAAMd,gBACNW,EAAWK,KAAMxF,GAAcsF,EAAMZ,mBAAqB1E,GAGxDiD,EAAQwC,iBAA8C,qBAApBH,EAAMI,YAG1CJ,EAAMI,UAAY7F,GAGpB,OAAA0F,EAAAN,EAASrB,IAAI0B,EAAMb,UAAnBc,EAA4BF,QAAStB,IACnCA,EAASlE,EAAQyF,QAGpBrC,GAGHkC,EACEH,EAASG,aACRQ,MAAMC,QAAQ3C,EAAQjD,WACnBiD,EAAQjD,UACR,CAACiD,EAAQjD,WAAa,IAE5BkF,EAAW,CACTH,KACAC,WACAC,YAGFtC,EAAYe,IAAIqB,EAAIG,EACtB,CAEA,OAAOA,CACT,CAmCqCW,CAAe5C,GAG5C6C,EAAYb,EAASrB,IAAIE,IAAY,GAQ3C,OAPKmB,EAASxB,IAAIK,IAChBmB,EAASvB,IAAII,EAASgC,GAGxBA,EAAUC,KAAKhC,GACfiB,EAASnB,QAAQC,GAEV,WAELgC,EAAUE,OAAOF,EAAUG,QAAQlC,GAAW,GAErB,IAArB+B,EAAU7B,SAEZgB,EAASiB,OAAOpC,GAChBkB,EAASmB,UAAUrC,IAGC,IAAlBmB,EAASmB,OAEXpB,EAASqB,aACT1D,EAAYuD,OAAOnB,GAEvB,CACF,CCzGO,IChEPuB,EAAAC,EDgEkCC,EAAAA,UE7B3B,SAAS1G,IAWiC,IAXvB,UACxBE,EAAA,MACAG,EAAA,gBACAsF,EAAA,WACAgB,EAAAjD,KACAA,EAAA,YACAzD,EAAA,KACA2G,EAAA,cACAC,EAAA,eACAxC,EAAA,SACAyC,GACF5C,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAyB,CAAC,EA9C1B,IAAAuB,EA+CE,MAAO3F,EAAKiH,GAAgBC,EAAAA,SAAyB,MAC/C/C,EAAiB+C,EAAAA,OAAwCF,GACzDG,EAAsBD,EAAAA,OAA4BH,IACjDK,EAAOC,GAAkBH,EAAAA,SAAgB,CAC9CjH,SAAU8G,EACVrB,WAAO,IAKTvB,EAASmD,QAAUN,EAGbE,EAAAA,UACJ,KAKE,QAJ8B,IAA1BC,EAAcG,UAChBH,EAAcG,QAAUP,GAGtBD,IAAS9G,EAAK,OAElB,IAAIuG,EAmCJ,OAlCAA,EAAYtC,EACVjE,EACA,CAACC,EAAQyF,KACP,MAAM6B,EAAiBJ,EAAcG,QACrCH,EAAcG,QAAUrH,QAGD,IAAnBsH,GAAiCtH,KAIrCoH,EAAS,CACPpH,SACAyF,UAEEvB,EAASmD,SAASnD,EAASmD,QAAQrH,EAAQyF,GAE3CA,EAAMd,gBAAkBzE,GAAeoG,IAEzCA,IACAA,OAAY,KAGhB,CACE3C,OACAiD,aACAzG,YAEAyF,kBACAtF,SAEFgE,GAGK,KACDgC,GACFA,MAMN,CAEER,MAAMC,QAAQ5F,GAAaA,EAAU2D,WAAa3D,EAClDJ,EACA4D,EACAiD,EACA1G,EACA2G,EACAjB,EACAtB,EACAhE,IAIJ,MAAMiH,EAAc,OAAA7B,EAAAyB,EAAM1B,YAAN,EAAAC,EAAad,OAC3B4C,EAA4BP,EAAAA,YAA4B,GAE3DlH,IACDwH,GACCrH,GACA2G,GACDW,EAAoBH,UAAYE,IAIhCC,EAAoBH,QAAUE,EAC9BH,EAAS,CACPpH,SAAU8G,EACVrB,WAAO,IAETyB,EAAcG,QAAUP,GAG1B,MAAMW,EAAS,CAACT,EAAQG,EAAMnH,OAAQmH,EAAM1B,OAO5C,OAJAgC,EAAO1H,IAAM0H,EAAO,GACpBA,EAAOzH,OAASyH,EAAO,GACvBA,EAAOhC,MAAQgC,EAAO,GAEfA,CACT,CD/II,OAAAf,EAAA,OAAAD,EAGAiB,EAAAA,oBAHAjB,EAIIiB,EAAAA,kBACAA,EAAAA,S","sources":["components/ProcessSteps.js","pages/ServicesPage.js","client.js","../node_modules/react-intersection-observer/src/observe.ts","../node_modules/react-intersection-observer/src/InView.tsx","../node_modules/react-intersection-observer/src/useOnInView.tsx","../node_modules/react-intersection-observer/src/useInView.tsx"],"sourcesContent":["// src/components/ProcessSteps.js\r\nimport React from 'react';\r\n\r\n// Hardcoded data based on the service slugs defined in your iconMap\r\nconst allServiceProcesses = {\r\n    'custom-software-development': [\r\n        { step: 1, title: 'Discovery & Planning', description: 'Define requirements, scope, and technical stack.' },\r\n        { step: 2, title: 'Design & Prototyping', description: 'Create user interfaces (UI/UX) and architecture design.' },\r\n        { step: 3, title: 'Agile Development', description: 'Develop in iterative sprints with continuous feedback.' },\r\n        { step: 4, title: 'Quality Assurance & Testing', description: 'Thoroughly test performance, security, and functionality.' },\r\n        { step: 5, title: 'Deployment & Launch', description: 'Deploy to production environment and monitor performance.' },\r\n    ],\r\n    'cloud-devops-infrastructure': [\r\n        { step: 1, title: 'Assessment & Strategy', description: 'Audit existing infrastructure and define migration/automation goals.' },\r\n        { step: 2, title: 'Architecture Design', description: 'Design scalable, cost-optimized cloud and CI/CD pipelines.' },\r\n        { step: 3, title: 'Automation Implementation', description: 'Implement Infrastructure-as-Code (IaC) and pipeline scripts.' },\r\n        { step: 4, title: 'Monitoring & Optimization', description: 'Set up real-time monitoring and fine-tune resources.' },\r\n    ],\r\n    'data-science-ai': [\r\n        { step: 1, title: 'Data Acquisition & Cleansing', description: 'Collect, validate, and prepare raw data for analysis.' },\r\n        { step: 2, title: 'Model Development', description: 'Develop, train, and test custom machine learning models.' },\r\n        { step: 3, title: 'Integration & Deployment', description: 'Integrate the model into the clientâ€™s existing application layer.' },\r\n        { step: 4, title: 'Performance Monitoring', description: 'Track model accuracy and retrain as needed for continuous improvement.' },\r\n    ],\r\n};\r\n\r\n\r\nconst ProcessSteps = ({ serviceSlug }) => {\r\n    const process = allServiceProcesses[serviceSlug] || [];\r\n    \r\n    // A simple container to make the process look visually distinct\r\n    return (\r\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 text-left\">\r\n            {process.map((item) => (\r\n                <div \r\n                    key={item.step} \r\n                    className=\"p-5 border border-blue-500 rounded-lg bg-blue-900/10 dark:bg-gray-800/50\"\r\n                >\r\n                    <span className=\"text-3xl font-extrabold text-blue-500 block mb-2\">\r\n                        {item.step}.\r\n                    </span>\r\n                    <h5 className=\"text-lg font-semibold text-gray-900 dark:text-white mb-1\">\r\n                        {item.title}\r\n                    </h5>\r\n                    <p className=\"text-sm text-gray-600 dark:text-gray-400\">\r\n                        {item.description}\r\n                    </p>\r\n                </div>\r\n            ))}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default ProcessSteps;","// src/pages/ServicesPage.js\r\nimport React, { useState, useEffect } from 'react';\r\nimport { Helmet } from 'react-helmet-async';\r\nimport { motion } from 'framer-motion';\r\nimport { useInView } from 'react-intersection-observer';\r\nimport { Link } from 'react-router-dom';\r\nimport { client } from '../client'; \r\nimport ProcessSteps from '../components/ProcessSteps'; // ðŸ‘ˆ NEW IMPORT\r\n\r\n// --- ICON MAP ---\r\nconst iconMap = {\r\n  'custom-software-development': (\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" strokeWidth={1.5} stroke=\"currentColor\" className=\"w-10 h-10\">\r\n      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M17.25 6.75 22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5 0-3 16.5\" />\r\n    </svg>\r\n  ),\r\n  'cloud-devops-infrastructure': (\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" strokeWidth={1.5} stroke=\"currentColor\" className=\"w-10 h-10\">\r\n      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M2.25 15a4.5 4.5 0 0 0 4.5 4.5H18a3.75 3.75 0 0 0 1.332-7.257 3 3 0 0 0-3.75-3.75 3 3 0 0 0-3.75 3.75H7.5a4.5 4.5 0 0 0-5.25 4.5Z\" />\r\n    </svg>\r\n  ),\r\n  'data-science-ai': (\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" strokeWidth={1.5} stroke=\"currentColor\" className=\"w-10 h-10\">\r\n      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M8.25 3v1.5M12 3v1.5M15.75 3v1.5M8.25 19.5V21M12 19.5V21M15.75 19.5V21M19.5 8.25H21M19.5 12H21M19.5 15.75H21M4.5 8.25H3M4.5 12H3M4.5 15.75H3M12 8.25v7.5M8.25 12h7.5\" />\r\n    </svg>\r\n  ),\r\n};\r\n\r\n// --- ANIMATION VARIANTS ---\r\nconst fadeInVariants = { hidden: { y: 20, opacity: 0 }, visible: { y: 0, opacity: 1, transition: { duration: 0.7 } } };\r\nfunction AnimatedListItem({ children, index }) {\r\n  const [ref, inView] = useInView({ triggerOnce: true, threshold: 0.1 });\r\n  const itemVariants = {\r\n    hidden: { x: -50, opacity: 0 },\r\n    visible: { x: 0, opacity: 1, transition: { duration: 0.5, delay: index * 0.2 } },\r\n  };\r\n  return (\r\n    <motion.div ref={ref} initial=\"hidden\" animate={inView ? \"visible\" : \"hidden\"} variants={itemVariants}>\r\n      {children}\r\n    </motion.div>\r\n  );\r\n}\r\n\r\n// --- MAIN PAGE COMPONENT ---\r\nfunction ServicesPage() {\r\n  const [services, setServices] = useState(null);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n\r\n  useEffect(() => {\r\n    // We are still fetching only basic data, but the new component uses the slug to get process data\r\n    const query = '*[_type == \"service\"]{ title, \"slug\": slug.current, description }'; \r\n    client.fetch(query)\r\n      .then((data) => {\r\n        setServices(data);\r\n        setIsLoading(false);\r\n      })\r\n      .catch((err) => {\r\n        console.error('Error fetching services:', err);\r\n        setError(err);\r\n        setIsLoading(false);\r\n      });\r\n  }, []);\r\n\r\n  const renderServiceContent = () => {\r\n    if (isLoading) {\r\n      return <p className=\"text-center text-lg text-gray-600 dark:text-gray-300\">Loading services...</p>;\r\n    }\r\n    if (error) {\r\n      return (\r\n        <div className=\"text-center p-8 bg-red-50 dark:bg-red-950 rounded-lg\">\r\n          <p className=\"text-lg text-red-600 dark:text-red-200\">\r\n            Sorry, we couldn't load our services at this time.\r\n          </p>\r\n        </div>\r\n      );\r\n    }\r\n    return (\r\n      <div className=\"space-y-24\"> {/* Increased spacing */}\r\n        {services && services.map((service, index) => (\r\n          <AnimatedListItem key={service.slug} index={index}>\r\n            {/* EXISTING Service Title & Description Block */}\r\n            <div className=\"flex flex-col md:flex-row items-start gap-8\">\r\n              <div className=\"flex-shrink-0 p-4 bg-blue-100 text-blue-600 \r\n                                 dark:bg-blue-900 dark:text-blue-300 rounded-full\">\r\n                {iconMap[service.slug]}\r\n              </div>\r\n              <div>\r\n                <h3 className=\"text-3xl font-bold text-gray-900 dark:text-white\">\r\n                  {service.title}\r\n                </h3>\r\n                <p className=\"mt-2 text-gray-600 dark:text-gray-300 text-lg\">\r\n                  {service.description}\r\n                </p>\r\n              </div>\r\n            </div>\r\n\r\n            {/* NEW: Process Steps Component */}\r\n            <div className=\"pt-12 mt-12 border-t border-gray-200 dark:border-gray-800\">\r\n                <h4 className=\"text-xl font-semibold mb-6 text-gray-900 dark:text-white\">\r\n                    Our Process for {service.title}\r\n                </h4>\r\n                {/* Passes the slug to the ProcessSteps component */}\r\n                <ProcessSteps serviceSlug={service.slug} /> \r\n            </div>\r\n          </AnimatedListItem>\r\n        ))}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <Helmet>\r\n        <title>Our Services | Nexus Solutions</title>\r\n        <meta \r\n          name=\"description\" \r\n          content=\"Explore our expert services: Custom Software Development, Cloud & DevOps Infrastructure, and Data Science & AI.\" \r\n        />\r\n      </Helmet>\r\n\r\n      {/* 1. Hero Header Section */}\r\n      <motion.div \r\n        className=\"bg-blue-50 py-20 text-center \r\n                  dark:bg-blue-950\r\n                  transition-colors duration-300 ease-in-out\"\r\n        initial=\"hidden\"\r\n        animate=\"visible\"\r\n        variants={fadeInVariants}\r\n      >\r\n        <h1 className=\"text-4xl md:text-6xl font-extrabold text-gray-900 dark:text-white\">\r\n          Our Services\r\n        </h1>\r\n        <p className=\"mt-4 text-lg md:text-xl text-gray-600 dark:text-blue-200 max-w-2xl mx-auto\">\r\n          Comprehensive solutions to accelerate your digital transformation.\r\n        </p>\r\n      </motion.div>\r\n\r\n      {/* 2. Detailed Services List */}\r\n      <section className=\"bg-white py-20 md:py-28 \r\n                          dark:bg-gray-900\r\n                          transition-colors duration-300 ease-in-out\">\r\n        <div className=\"container mx-auto px-6\">\r\n          {renderServiceContent()}\r\n        </div>\r\n      </section>\r\n\r\n      {/* 3. Call to Action Section */}\r\n      <section className=\"bg-gray-900 \r\n                          dark:bg-gray-950\r\n                          transition-colors duration-300 ease-in-out\">\r\n          <div className=\"container mx-auto px-6 py-20 text-center\">\r\n            <h2 className=\"text-3xl md:text-4xl font-extrabold text-white\">\r\n              Have a project in mind?\r\n            </h2>\r\n            <p className=\"mt-4 text-lg text-gray-300 max-w-2xl mx-auto\">\r\n              Let's discuss how our team can help you achieve your goals.\r\n            </p>\r\n            <Link \r\n              to=\"/#contact\" \r\n              className=\"inline-block bg-blue-600 text-white px-8 py-3 rounded-lg text-lg font-medium \r\n                        hover:bg-blue-700 transition duration-300 mt-10\"\r\n            >\r\n              Get in Touch\r\n            </Link>\r\n          </div>\r\n      </section>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default ServicesPage;","// src/client.js\r\nimport { createClient } from '@sanity/client';\r\nimport imageUrlBuilder from '@sanity/image-url';\r\n\r\n// This is your connection details\r\nexport const client = createClient({\r\n  projectId: \"m4s7pq0x\", // ðŸ‘ˆ Paste your projectId here\r\n  dataset: \"production\",\r\n  useCdn: true, // `false` if you want to ensure fresh data\r\n  apiVersion: '2023-05-03', // Use a current date\r\n});\r\n\r\n// This is a helper function to get image URLs\r\nconst builder = imageUrlBuilder(client);\r\nexport const urlFor = (source) => builder.image(source);","import type { ObserverInstanceCallback } from \"./index\";\n\nconst observerMap = new Map<\n  string,\n  {\n    id: string;\n    observer: IntersectionObserver;\n    elements: Map<Element, Array<ObserverInstanceCallback>>;\n  }\n>();\n\nconst RootIds: WeakMap<Element | Document, string> = new WeakMap();\nlet rootId = 0;\n\nlet unsupportedValue: boolean | undefined;\n\n/**\n * What should be the default behavior if the IntersectionObserver is unsupported?\n * Ideally the polyfill has been loaded, you can have the following happen:\n * - `undefined`: Throw an error\n * - `true` or `false`: Set the `inView` value to this regardless of intersection state\n * **/\nexport function defaultFallbackInView(inView: boolean | undefined) {\n  unsupportedValue = inView;\n}\n\n/**\n * Generate a unique ID for the root element\n * @param root\n */\nfunction getRootId(root: IntersectionObserverInit[\"root\"]) {\n  if (!root) return \"0\";\n  if (RootIds.has(root)) return RootIds.get(root);\n  rootId += 1;\n  RootIds.set(root, rootId.toString());\n  return RootIds.get(root);\n}\n\n/**\n * Convert the options to a string Id, based on the values.\n * Ensures we can reuse the same observer when observing elements with the same options.\n * @param options\n */\nexport function optionsToId(options: IntersectionObserverInit) {\n  return Object.keys(options)\n    .sort()\n    .filter(\n      (key) => options[key as keyof IntersectionObserverInit] !== undefined,\n    )\n    .map((key) => {\n      return `${key}_${\n        key === \"root\"\n          ? getRootId(options.root)\n          : options[key as keyof IntersectionObserverInit]\n      }`;\n    })\n    .toString();\n}\n\nfunction createObserver(options: IntersectionObserverInit) {\n  // Create a unique ID for this observer instance, based on the root, root margin and threshold.\n  const id = optionsToId(options);\n  let instance = observerMap.get(id);\n\n  if (!instance) {\n    // Create a map of elements this observer is going to observe. Each element has a list of callbacks that should be triggered, once it comes into view.\n    const elements = new Map<Element, Array<ObserverInstanceCallback>>();\n    let thresholds: number[] | readonly number[];\n\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        // While it would be nice if you could just look at isIntersecting to determine if the component is inside the viewport, browsers can't agree on how to use it.\n        // -Firefox ignores `threshold` when considering `isIntersecting`, so it will never be false again if `threshold` is > 0\n        const inView =\n          entry.isIntersecting &&\n          thresholds.some((threshold) => entry.intersectionRatio >= threshold);\n\n        // @ts-expect-error support IntersectionObserver v2\n        if (options.trackVisibility && typeof entry.isVisible === \"undefined\") {\n          // The browser doesn't support Intersection Observer v2, falling back to v1 behavior.\n          // @ts-expect-error\n          entry.isVisible = inView;\n        }\n\n        elements.get(entry.target)?.forEach((callback) => {\n          callback(inView, entry);\n        });\n      });\n    }, options);\n\n    // Ensure we have a valid thresholds array. If not, use the threshold from the options\n    thresholds =\n      observer.thresholds ||\n      (Array.isArray(options.threshold)\n        ? options.threshold\n        : [options.threshold || 0]);\n\n    instance = {\n      id,\n      observer,\n      elements,\n    };\n\n    observerMap.set(id, instance);\n  }\n\n  return instance;\n}\n\n/**\n * @param element - DOM Element to observe\n * @param callback - Callback function to trigger when intersection status changes\n * @param options - Intersection Observer options\n * @param fallbackInView - Fallback inView value.\n * @return Function - Cleanup function that should be triggered to unregister the observer\n */\nexport function observe(\n  element: Element,\n  callback: ObserverInstanceCallback,\n  options: IntersectionObserverInit = {},\n  fallbackInView = unsupportedValue,\n) {\n  if (\n    typeof window.IntersectionObserver === \"undefined\" &&\n    fallbackInView !== undefined\n  ) {\n    const bounds = element.getBoundingClientRect();\n    callback(fallbackInView, {\n      isIntersecting: fallbackInView,\n      target: element,\n      intersectionRatio:\n        typeof options.threshold === \"number\" ? options.threshold : 0,\n      time: 0,\n      boundingClientRect: bounds,\n      intersectionRect: bounds,\n      rootBounds: bounds,\n    });\n    return () => {\n      // Nothing to cleanup\n    };\n  }\n  // An observer with the same options can be reused, so lets use this fact\n  const { id, observer, elements } = createObserver(options);\n\n  // Register the callback listener for this element\n  const callbacks = elements.get(element) || [];\n  if (!elements.has(element)) {\n    elements.set(element, callbacks);\n  }\n\n  callbacks.push(callback);\n  observer.observe(element);\n\n  return function unobserve() {\n    // Remove the callback from the callback list\n    callbacks.splice(callbacks.indexOf(callback), 1);\n\n    if (callbacks.length === 0) {\n      // No more callback exists for element, so destroy it\n      elements.delete(element);\n      observer.unobserve(element);\n    }\n\n    if (elements.size === 0) {\n      // No more elements are being observer by this instance, so destroy it\n      observer.disconnect();\n      observerMap.delete(id);\n    }\n  };\n}\n","import * as React from \"react\";\nimport type { IntersectionObserverProps, PlainChildrenProps } from \"./index\";\nimport { observe } from \"./observe\";\n\ntype State = {\n  inView: boolean;\n  entry?: IntersectionObserverEntry;\n};\n\nfunction isPlainChildren(\n  props: IntersectionObserverProps | PlainChildrenProps,\n): props is PlainChildrenProps {\n  return typeof props.children !== \"function\";\n}\n\n/**\n ## Render props\n\n To use the `<InView>` component, you pass it a function. It will be called\n whenever the state changes, with the new value of `inView`. In addition to the\n `inView` prop, children also receive a `ref` that should be set on the\n containing DOM element. This is the element that the IntersectionObserver will\n monitor.\n\n If you need it, you can also access the\n [`IntersectionObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)\n on `entry`, giving you access to all the details about the current intersection\n state.\n\n ```jsx\n import { InView } from 'react-intersection-observer';\n\n const Component = () => (\n <InView>\n {({ inView, ref, entry }) => (\n      <div ref={ref}>\n        <h2>{`Header inside viewport ${inView}.`}</h2>\n      </div>\n    )}\n </InView>\n );\n\n export default Component;\n ```\n\n ## Plain children\n\n You can pass any element to the `<InView />`, and it will handle creating the\n wrapping DOM element. Add a handler to the `onChange` method, and control the\n state in your own component. Any extra props you add to `<InView>` will be\n passed to the HTML element, allowing you set the `className`, `style`, etc.\n\n ```jsx\n import { InView } from 'react-intersection-observer';\n\n const Component = () => (\n <InView as=\"div\" onChange={(inView, entry) => console.log('Inview:', inView)}>\n <h2>Plain children are always rendered. Use onChange to monitor state.</h2>\n </InView>\n );\n\n export default Component;\n ```\n */\nexport class InView extends React.Component<\n  IntersectionObserverProps | PlainChildrenProps,\n  State\n> {\n  node: Element | null = null;\n  _unobserveCb: (() => void) | null = null;\n  lastInView: boolean | undefined;\n\n  constructor(props: IntersectionObserverProps | PlainChildrenProps) {\n    super(props);\n    this.state = {\n      inView: !!props.initialInView,\n      entry: undefined,\n    };\n    this.lastInView = props.initialInView;\n  }\n\n  componentDidMount() {\n    this.unobserve();\n    this.observeNode();\n  }\n\n  componentDidUpdate(prevProps: IntersectionObserverProps) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (\n      prevProps.rootMargin !== this.props.rootMargin ||\n      prevProps.root !== this.props.root ||\n      prevProps.threshold !== this.props.threshold ||\n      prevProps.skip !== this.props.skip ||\n      prevProps.trackVisibility !== this.props.trackVisibility ||\n      prevProps.delay !== this.props.delay\n    ) {\n      this.unobserve();\n      this.observeNode();\n    }\n  }\n\n  componentWillUnmount() {\n    this.unobserve();\n  }\n\n  observeNode() {\n    if (!this.node || this.props.skip) return;\n    const {\n      threshold,\n      root,\n      rootMargin,\n      trackVisibility,\n      delay,\n      fallbackInView,\n    } = this.props;\n\n    if (this.lastInView === undefined) {\n      this.lastInView = this.props.initialInView;\n    }\n    this._unobserveCb = observe(\n      this.node,\n      this.handleChange,\n      {\n        threshold,\n        root,\n        rootMargin,\n        // @ts-expect-error\n        trackVisibility,\n        delay,\n      },\n      fallbackInView,\n    );\n  }\n\n  unobserve() {\n    if (this._unobserveCb) {\n      this._unobserveCb();\n      this._unobserveCb = null;\n    }\n  }\n\n  handleNode = (node?: Element | null) => {\n    if (this.node) {\n      // Clear the old observer, before we start observing a new element\n      this.unobserve();\n\n      if (!node && !this.props.triggerOnce && !this.props.skip) {\n        // Reset the state if we get a new node, and we aren't ignoring updates\n        this.setState({ inView: !!this.props.initialInView, entry: undefined });\n        this.lastInView = this.props.initialInView;\n      }\n    }\n\n    this.node = node ? node : null;\n    this.observeNode();\n  };\n\n  handleChange = (inView: boolean, entry: IntersectionObserverEntry) => {\n    const previousInView = this.lastInView;\n    this.lastInView = inView;\n\n    // Ignore the very first `false` notification so consumers only hear about actual state changes.\n    if (previousInView === undefined && !inView) {\n      return;\n    }\n\n    if (inView && this.props.triggerOnce) {\n      // If `triggerOnce` is true, we should stop observing the element.\n      this.unobserve();\n    }\n    if (!isPlainChildren(this.props)) {\n      // Store the current State, so we can pass it to the children in the next render update\n      // There's no reason to update the state for plain children, since it's not used in the rendering.\n      this.setState({ inView, entry });\n    }\n    if (this.props.onChange) {\n      // If the user is actively listening for onChange, always trigger it\n      this.props.onChange(inView, entry);\n    }\n  };\n\n  render() {\n    const { children } = this.props;\n    if (typeof children === \"function\") {\n      const { inView, entry } = this.state;\n      return children({ inView, entry, ref: this.handleNode });\n    }\n\n    const {\n      as,\n      triggerOnce,\n      threshold,\n      root,\n      rootMargin,\n      onChange,\n      skip,\n      trackVisibility,\n      delay,\n      initialInView,\n      fallbackInView,\n      ...props\n    } = this.props as PlainChildrenProps;\n\n    return React.createElement(\n      as || \"div\",\n      { ref: this.handleNode, ...props },\n      children,\n    );\n  }\n}\n","import * as React from \"react\";\nimport type {\n  IntersectionChangeEffect,\n  IntersectionEffectOptions,\n} from \"./index\";\nimport { observe } from \"./observe\";\n\nconst useSyncEffect =\n  (\n    React as typeof React & {\n      useInsertionEffect?: typeof React.useEffect;\n    }\n  ).useInsertionEffect ??\n  React.useLayoutEffect ??\n  React.useEffect;\n\n/**\n * React Hooks make it easy to monitor when elements come into and leave view. Call\n * the `useOnInView` hook with your callback and (optional) [options](#options).\n * It will return a ref callback that you can assign to the DOM element you want to monitor.\n * When the element enters or leaves the viewport, your callback will be triggered.\n *\n * This hook triggers no re-renders, and is useful for performance-critical use-cases or\n * when you need to trigger render independent side effects like tracking or logging.\n *\n * @example\n * ```jsx\n * import React from 'react';\n * import { useOnInView } from 'react-intersection-observer';\n *\n * const Component = () => {\n *   const inViewRef = useOnInView((inView, entry) => {\n *     if (inView) {\n *       console.log(\"Element is in view\", entry.target);\n *     } else {\n *       console.log(\"Element left view\", entry.target);\n *     }\n *   });\n *\n *   return (\n *     <div ref={inViewRef}>\n *       <h2>This element is being monitored</h2>\n *     </div>\n *   );\n * };\n * ```\n */\nexport const useOnInView = <TElement extends Element>(\n  onIntersectionChange: IntersectionChangeEffect<TElement>,\n  {\n    threshold,\n    root,\n    rootMargin,\n    trackVisibility,\n    delay,\n    triggerOnce,\n    skip,\n  }: IntersectionEffectOptions = {},\n) => {\n  const onIntersectionChangeRef = React.useRef(onIntersectionChange);\n  const observedElementRef = React.useRef<TElement | null>(null);\n  const observerCleanupRef = React.useRef<(() => void) | undefined>(undefined);\n  const lastInViewRef = React.useRef<boolean | undefined>(undefined);\n\n  useSyncEffect(() => {\n    onIntersectionChangeRef.current = onIntersectionChange;\n  }, [onIntersectionChange]);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: Threshold arrays are normalized inside the callback\n  return React.useCallback(\n    (element: TElement | undefined | null) => {\n      // React <19 never calls ref callbacks with `null` during unmount, so we\n      // eagerly tear down existing observers manually whenever the target changes.\n      const cleanupExisting = () => {\n        if (observerCleanupRef.current) {\n          const cleanup = observerCleanupRef.current;\n          observerCleanupRef.current = undefined;\n          cleanup();\n        }\n      };\n\n      if (element === observedElementRef.current) {\n        return observerCleanupRef.current;\n      }\n\n      if (!element || skip) {\n        cleanupExisting();\n        observedElementRef.current = null;\n        lastInViewRef.current = undefined;\n        return;\n      }\n\n      cleanupExisting();\n\n      observedElementRef.current = element;\n      let destroyed = false;\n\n      const destroyObserver = observe(\n        element,\n        (inView, entry) => {\n          const previousInView = lastInViewRef.current;\n          lastInViewRef.current = inView;\n\n          // Ignore the very first `false` notification so consumers only hear about actual state changes.\n          if (previousInView === undefined && !inView) {\n            return;\n          }\n\n          onIntersectionChangeRef.current(\n            inView,\n            entry as IntersectionObserverEntry & { target: TElement },\n          );\n          if (triggerOnce && inView) {\n            stopObserving();\n          }\n        },\n        {\n          threshold,\n          root,\n          rootMargin,\n          trackVisibility,\n          delay,\n        } as IntersectionObserverInit,\n      );\n\n      function stopObserving() {\n        // Centralized teardown so both manual destroys and React ref updates share\n        // the same cleanup path (needed for React versions that never call the ref with `null`).\n        if (destroyed) return;\n        destroyed = true;\n        destroyObserver();\n        observedElementRef.current = null;\n        observerCleanupRef.current = undefined;\n        lastInViewRef.current = undefined;\n      }\n\n      observerCleanupRef.current = stopObserving;\n\n      return observerCleanupRef.current;\n    },\n    [\n      Array.isArray(threshold) ? threshold.toString() : threshold,\n      root,\n      rootMargin,\n      trackVisibility,\n      delay,\n      triggerOnce,\n      skip,\n    ],\n  );\n};\n","import * as React from \"react\";\nimport type { IntersectionOptions, InViewHookResponse } from \"./index\";\nimport { observe } from \"./observe\";\n\ntype State = {\n  inView: boolean;\n  entry?: IntersectionObserverEntry;\n};\n\n/**\n * React Hooks make it easy to monitor the `inView` state of your components. Call\n * the `useInView` hook with the (optional) [options](#options) you need. It will\n * return an array containing a `ref`, the `inView` status and the current\n * [`entry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry).\n * Assign the `ref` to the DOM element you want to monitor, and the hook will\n * report the status.\n *\n * @example\n * ```jsx\n * import React from 'react';\n * import { useInView } from 'react-intersection-observer';\n *\n * const Component = () => {\n *   const { ref, inView, entry } = useInView({\n *       threshold: 0,\n *   });\n *\n *   return (\n *     <div ref={ref}>\n *       <h2>{`Header inside viewport ${inView}.`}</h2>\n *     </div>\n *   );\n * };\n * ```\n */\nexport function useInView({\n  threshold,\n  delay,\n  trackVisibility,\n  rootMargin,\n  root,\n  triggerOnce,\n  skip,\n  initialInView,\n  fallbackInView,\n  onChange,\n}: IntersectionOptions = {}): InViewHookResponse {\n  const [ref, setRef] = React.useState<Element | null>(null);\n  const callback = React.useRef<IntersectionOptions[\"onChange\"]>(onChange);\n  const lastInViewRef = React.useRef<boolean | undefined>(initialInView);\n  const [state, setState] = React.useState<State>({\n    inView: !!initialInView,\n    entry: undefined,\n  });\n\n  // Store the onChange callback in a `ref`, so we can access the latest instance\n  // inside the `useEffect`, but without triggering a rerender.\n  callback.current = onChange;\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: threshold is not correctly detected as a dependency\n  React.useEffect(\n    () => {\n      if (lastInViewRef.current === undefined) {\n        lastInViewRef.current = initialInView;\n      }\n      // Ensure we have node ref, and that we shouldn't skip observing\n      if (skip || !ref) return;\n\n      let unobserve: (() => void) | undefined;\n      unobserve = observe(\n        ref,\n        (inView, entry) => {\n          const previousInView = lastInViewRef.current;\n          lastInViewRef.current = inView;\n\n          // Ignore the very first `false` notification so consumers only hear about actual state changes.\n          if (previousInView === undefined && !inView) {\n            return;\n          }\n\n          setState({\n            inView,\n            entry,\n          });\n          if (callback.current) callback.current(inView, entry);\n\n          if (entry.isIntersecting && triggerOnce && unobserve) {\n            // If it should only trigger once, unobserve the element after it's inView\n            unobserve();\n            unobserve = undefined;\n          }\n        },\n        {\n          root,\n          rootMargin,\n          threshold,\n          // @ts-expect-error\n          trackVisibility,\n          delay,\n        },\n        fallbackInView,\n      );\n\n      return () => {\n        if (unobserve) {\n          unobserve();\n        }\n      };\n    },\n    // We break the rule here, because we aren't including the actual `threshold` variable\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      // If the threshold is an array, convert it to a string, so it won't change between renders.\n      Array.isArray(threshold) ? threshold.toString() : threshold,\n      ref,\n      root,\n      rootMargin,\n      triggerOnce,\n      skip,\n      trackVisibility,\n      fallbackInView,\n      delay,\n    ],\n  );\n\n  const entryTarget = state.entry?.target;\n  const previousEntryTarget = React.useRef<Element | undefined>(undefined);\n  if (\n    !ref &&\n    entryTarget &&\n    !triggerOnce &&\n    !skip &&\n    previousEntryTarget.current !== entryTarget\n  ) {\n    // If we don't have a node ref, then reset the state (unless the hook is set to only `triggerOnce` or `skip`)\n    // This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView\n    previousEntryTarget.current = entryTarget;\n    setState({\n      inView: !!initialInView,\n      entry: undefined,\n    });\n    lastInViewRef.current = initialInView;\n  }\n\n  const result = [setRef, state.inView, state.entry] as InViewHookResponse;\n\n  // Support object destructuring, by adding the specific values.\n  result.ref = result[0];\n  result.inView = result[1];\n  result.entry = result[2];\n\n  return result;\n}\n"],"names":["allServiceProcesses","step","title","description","_ref","serviceSlug","process","_jsx","className","children","map","item","_jsxs","iconMap","xmlns","fill","viewBox","strokeWidth","stroke","strokeLinecap","strokeLinejoin","d","fadeInVariants","hidden","y","opacity","visible","transition","duration","AnimatedListItem","index","ref","inView","useInView","triggerOnce","threshold","itemVariants","x","delay","motion","div","initial","animate","variants","services","setServices","useState","isLoading","setIsLoading","error","setError","useEffect","client","fetch","then","data","catch","err","console","Helmet","name","content","service","slug","ProcessSteps","Link","to","createClient","projectId","dataset","useCdn","apiVersion","builder","imageUrlBuilder","urlFor","source","image","unsupportedValue","observerMap","Map","RootIds","WeakMap","rootId","optionsToId","options","Object","keys","sort","filter","key","concat","root","has","set","toString","get","observe","element","callback","arguments","length","undefined","fallbackInView","window","IntersectionObserver","bounds","getBoundingClientRect","isIntersecting","target","intersectionRatio","time","boundingClientRect","intersectionRect","rootBounds","id","observer","elements","instance","thresholds","entries","forEach","entry","_a2","some","trackVisibility","isVisible","Array","isArray","createObserver","callbacks","push","splice","indexOf","delete","unobserve","size","disconnect","_a","_b","React","rootMargin","skip","initialInView","onChange","setRef","React2","lastInViewRef","state","setState","current","previousInView","entryTarget","previousEntryTarget","result","React3"],"sourceRoot":""}